"""
conversational_facing.py

Module for generating LinuxCNC G-code for facing operations in Probe Basic Lathe.
"""

def collect_facing_parameters_from_ui(ui):
    """
    Collect facing parameters using the YAML VCP setting names.
    Uses getSetting(setting_name).getValue() for each parameter.
    Adds debug output for each setting.
    """
    from qtpyvcp.utilities.settings import getSetting

    # Map: setting_name -> debug label
    setting_map = [
        ('facing.wcs', 'wcs'),
        ('facing.tool', 'tool'),
        ('facing.units', 'units'),
        ('facing.diam-rad', 'diam_rad'),
        ('facing.coolant', 'coolant'),
        ('facing.feed-mode', 'feed_mode'),
        ('facing.rough-feedrate', 'rough_feed'),
        ('facing.finish-feedrate', 'finish_feed'),
        ('facing.rpm-mode', 'rpm_mode'),
        ('facing.rpm', 'rpm'),
        ('facing.max-rpm', 'max_rpm'),
        ('facing.sf-speed-rough', 'rough_ssp'),
        ('facing.sf-speed-finish', 'finish_ssp'),
        ('facing.rotation', 'rotation'),
        ('facing.clearance', 'clearance'),
        ('facing.x-start-diam', 'x_start'),
        ('facing.x-end-diam', 'x_end'),
        ('facing.z-start', 'z_start'),
        ('facing.z-end', 'z_end'),
        ('facing.rough-step', 'rough_step'),
        ('facing.finish-step', 'finish_step'),
    ]

    params = {}
    for setting, label in setting_map:
        try:
            val = getSetting(setting).getValue()
            print(f"[DEBUG] Setting '{setting}' ({label}): {val}")
            params[label] = val
        except Exception as e:
            print(f"[DEBUG] Error getting setting '{setting}': {e}")
            params[label] = None

    print("[DEBUG] Final collected facing parameters (from settings):")
    for k, v in params.items():
        print(f"    {k}: {v}")
    return params

def generate_facing_gcode(params):
    """
    Generate LinuxCNC G-code for a facing operation using the provided parameters dict.
    Returns a string containing the G-code program.
    """
    # Helper: get int or str for G/M codes
    def as_int(val, default=0):
        try:
            return int(float(val))
        except Exception:
            return default
    def as_float(val, default=0.0):
        try:
            return float(val)
        except Exception:
            return default
    def as_str(val, default=""):
        try:
            return str(val)
        except Exception:
            return default

    # G/M code mappings
    units_code = as_int(params.get('units', 20))
    gcode_units = 'G20' if units_code == 20 else 'G21'
    feed_mode_code = as_int(params.get('feed_mode', 94))
    gcode_feed_mode = 'G94' if feed_mode_code == 94 else 'G95'
    rpm_mode_code = as_int(params.get('rpm_mode', 96))
    gcode_rpm_mode = 'G96' if rpm_mode_code == 96 else 'G97'
    spindle_dir_code = as_int(params.get('rotation', 3))
    gcode_spindle_dir = 'M3' if spindle_dir_code == 3 else 'M4'
    coolant_code = as_int(params.get('coolant', 9))
    gcode_coolant = {7: 'M7', 8: 'M8', 9: 'M9'}.get(coolant_code, 'M9')
    diam_rad_code = as_int(params.get('diam_rad', 7))
    gcode_diam_rad = 'G7' if diam_rad_code == 7 else 'G8'
    wcs_val = params.get('wcs', 54)
    gcode_wcs = f"G{as_int(wcs_val, 54)}" if isinstance(wcs_val, (int, float)) or str(wcs_val).isdigit() else as_str(wcs_val, "G54")
    tool_val = as_int(params.get('tool', 0))

    # Numeric values (now using correct keys)
    rpm_val = as_float(params.get('rpm', 500))
    max_rpm_val = as_float(params.get('max_rpm', 1000))
    rough_ssp_val = as_float(params.get('rough_ssp', 0))
    finish_ssp_val = as_float(params.get('finish_ssp', 0))
    rough_feed_val = as_float(params.get('rough_feed', 0.1))
    finish_feed_val = as_float(params.get('finish_feed', 0.05))
    clearance_val = as_float(params.get('clearance', 2))
    x_start = as_float(params.get('x_start', 50))
    x_end = as_float(params.get('x_end', 0))
    z_start = as_float(params.get('z_start', 2))
    z_end = as_float(params.get('z_end', 0))
    rough_step = as_float(params.get('rough_step', 1))
    finish_step = as_float(params.get('finish_step', 0.2))

    gcode = f"""(Facing Operation Generated by Probe Basic Lathe)
{gcode_units} (Set units)
{gcode_diam_rad} (Diameter/Radius mode)
G18 (XZ plane select)
{gcode_feed_mode} (Feed mode)
{gcode_wcs} (Work coordinate system)
T{tool_val} (Tool number)
M6 (Tool change)
{gcode_coolant} (Coolant)
{gcode_spindle_dir} (Spindle direction)
"""

    # Spindle speed and mode
    if gcode_rpm_mode == 'G97':
        gcode += f"S{rpm_val:.4f} (Spindle RPM)\n"
        gcode += f"{gcode_rpm_mode} (RPM mode)\n"
    elif gcode_rpm_mode == 'G96':
        gcode += f"{gcode_rpm_mode} D{max_rpm_val:.4f} S{rough_ssp_val:.4f} (CSS: D=Max RPM, S=Surface Speed)\n"

    gcode += "M3 (Spindle start)\n" if gcode_spindle_dir == 'M3' else "M4 (Spindle start, reverse)\n"

    # --- Calculate facing Z positions as per user scenario ---
    z_positions = []
    total_cut = abs(z_end - z_start)
    rough_distance = total_cut - finish_step
    if rough_distance < 0:
        # If finish_step is greater than total_cut, just do one pass at z_end
        z_positions = [z_end]
    else:
        rough_passes_float = rough_distance / rough_step
        rough_passes = int(rough_passes_float)
        fractional = rough_passes_float - rough_passes

        # Determine direction
        direction = 1 if z_end > z_start else -1

        # First pass is the fractional step (if any)
        current_z = z_start
        if fractional > 1e-6:
            first_step = rough_step * fractional
            current_z += direction * first_step
            z_positions.append(round(current_z, 6))
        # Full rough passes
        for i in range(rough_passes):
            current_z += direction * rough_step
            z_positions.append(round(current_z, 6))
        # Final finish pass
        z_positions.append(z_end)

    # Generate G-code for each Z position
    for i, z_pos in enumerate(z_positions):
        is_last = (i == len(z_positions) - 1)
        feed = finish_feed_val if is_last else rough_feed_val
        x_safe = x_start + clearance_val

        gcode += f"(Pass {i+1}: {'Finishing' if is_last else 'Roughing'} at Z={z_pos:.4f})\n"
        # Rapid to safe X and Z for this pass
        gcode += f"G0 X{x_safe:.4f} Z{z_pos + clearance_val:.4f}\n"
        # Approach Z cut position with feedrate (G1 with F)
        gcode += f"G1 Z{z_pos:.4f} F{feed:.4f}\n"
        # Approach X start (no need to repeat F, modal)
        gcode += f"G1 X{x_start:.4f}\n"
        # Cut along X to X_end
        gcode += f"G1 X{x_end:.4f}\n"
        # Retract Z away from stock
        gcode += f"G0 Z{z_pos + clearance_val:.4f}\n"
        # Retract X to safe
        gcode += f"G0 X{x_safe:.4f}\n"

    gcode += "M5 (Spindle stop)\n"
    gcode += "M9 (Coolant off)\n"
    gcode += "M30 (End of program)\n"
    return gcode
